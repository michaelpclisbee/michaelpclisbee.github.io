## Introduction
This ePortfolio contains a narrated code review, an ePortfolio Selection and Refinement Plan, enhancements to existing work in three categories:  Software Design and Engineering, Algorithms and Data Structure, and Databases, narratives justifying each enhancement, and a professional Self Assessment. These artifacts were initially created over the life of my time completing the Computer Science program at Southern New Hampshire University (SNHU).  The resulting enhancements expand on the basic principles of each category, and are intended to showcase my abilities in each area.   




## Table of Contents


* [Professional Self Assessment](#professional-self-assessment)
* Informal Code Review [(YouTube Link)](https://youtu.be/gQ-wygnmFLA)
* [ePortfolio Selection and Refinement Plan](#ePortfolio-selection-and-refinement-plan)
* [Category I: Software Engineering and Design](#ePortfolio-selection-and-refinement-plan)  
* [Category II: Algorithm and Data Structures](#ePortfolio-selection-and-refinement-plan)
* [Category III: Databases](#ePortfolio-selection-and-refinement-plan)


## [Professional Self Assessment](#Introduction)
[(Download)](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Professional%20Self%20Assessment.docx)

This Professional Self-Assessment will serve as a summation of my experiences navigating through the Computer Science program at SNHU and introduce the artifacts chosen for my final project in the Capstone class of the SNHU Computer Science program.  Completing my coursework throughout the Computer Science Program over the last four years and developing an ePortfolio has helped to showcase my strengths and shape my professional goals and values and helped me to be more employable in the computer science field.  

<details><summary>CLICK TO EXPAND</summary>
<p>

Learning to create effective security policies that implement structures that enforce coding standards and best practices, as well as how the Software Development Life Cycle (SDLC) functions has been instrumental in my understanding of team environment collaboration.  Understanding how each team member has their own classification and assigned duties, how they all link together to create solid planning, creating, testing and deployment stages was beneficial. understanding how everyone had their own assignment or branch off of the same project yet linked to the team as a whole for peer code review and testing, then finally submitted coding from their branches into the main structure for further development.  Understanding these concepts and being able to employ them will make me a more effective team member in the future.  For example, the CS-310 Collaboration and Group Project course introduced me to the GIT process and understanding version control, another definition of team collaboration using centralized project storage, with all members of a team accessing the latest version and merging it into their project branches, making the process seamless.

Another concept involving SDLC, communicating with stakeholders is an integral part of the process for a successful project.  As learned throughout this program, not gaining transparency and insight with the client or stakeholders will lead to process delay and possibly failure.  Keeping an open line of communication early in the process will clarify client requirements, work out any misunderstandings or gaps in communication, as well as minimize rehashing and altering development late in the cycle.  After all, the clients are the ones you are creating these projects for, so it is essential to understand one another’s mindset. 

Multiple classes throughout this program involved data structure and algorithm creation, as these are the building blocks for more advanced code to grow from.  Understanding how these are associated with each other and having the ability to express this through code is an essential component of the computer science program.  Most programs incorporate these concepts and would cease to function without them.  The concepts of databases and software engineering were found to be the most interesting, as they are the most visual with interactive GUI and understanding all that goes into ensuring a database program will function properly.  Included in this would be the addition of error handling and security measures to ensure minimal issues.  Security is a cornerstone of any project development to ensure no outside or inside forces gain unauthorized access to privileged data. This security can come in many shapes, to include multi factor authorization protocols, to physical security policies that companies can enforce to ensure data integrity.

Overall, I was introduced to Python in CS-200, CS-250 taught about Scrum, I learned testing and its importance in CS-310. I learned how to incorporate Discrete Math, Stats, Calculus, Physics, and Linear Algebra into computer science as a whole. I gained knowledge on databases and analyzing data. I learned about computational graphics and design. I now understand how to use Python, C++, Java, and other useful applications. All of these skills learned with be essential when utilizing them in my future endeavors.

**Final Portfolio Summary**

For this project, I chose three artifacts that made the most educational impact on me. I selected projects that I really believe I would continue to use in my professional life after the requirements for this class were completed. From software design and testing to base algorithm coding for working data structures, and the creation of user-friendly databases centered on the client requirements, all of these artifacts fit together to create a fully rounded demonstration of skills and abilities learned throughout this program.  

For the software design and engineering portion of the project, I applied what I learned in CS-320 Software Testing, Automation and Quality Assurance.   This centered around testing automated coding ion Javascript with adequate error handling through JUnit tests. To accomplish this, I took the skills that I learned in CS-320 and applied additional testing methods to include assertEquals, assertThrows and assertUpdate, as well as adding constructor variations that effectively test variable combinations entered by the user. This portion demonstrates my skills in software design and engineering by expanding the complexity of my error handling to cover a wide range of outcomes using Javascript.

For the algorithms and data structures portion of the project, I chose to apply my knowledge from CS-250 Software Development Life Cycle to enhance the efficiency and complexity of an API that displays working button controls, frame and panel attributes, and image and text selection.  This involved using multiple data structures to store image and sizing data, as well as associated descriptive text.  These have associated algorithms which employ postfix increment and decrement operators linked to button controls that in ultimately control which data and image set to display.  This demonstrates my skills with algorithms and data structures, as well as my ability to effectively use Javascript.

For the databases portion of the final project, I applied what I learned in the CS-340 Advanced Programming Concepts course and enhanced a mongoDB based database written in Python that will interface with a Node JS application. This application provides a user-friendly interface that pulls data from a central .csv file, with the objective of helping a client identify good dog candidates for search and rescue training through a dynamic dashboard web application that can be run either with MongoDB or Jupyter Notebook.  I incorporated what I learned about mongoDB and added in enhanced functionality to the password interface for added access security, and expanded coding for data creation, alteration and deletion into an existing data structure.  This incorporated additional error notifications and loops to enhance error handling.  This portion demonstrates my skills with databases, as well as my ability to use Python.
</p>
</details>



## [ePortfolio Selection and Refinement Plan](#Introduction)
[(Download)](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/ePortfolio%20Selection%20and%20Refinement%20Plan.docx)



## [Category I: Software Engineering and Design](#Introduction)
[Original I Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat1%20Initial.zip)    
-[Enhancement I Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat1_Software%20Engineering%20and%20Design.zip)
-[Enhancement I Narrative](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%201%20Narrative.docx)
 
<details><summary>CLICK TO EXPAND</summary>
<p>
 For Artifact One in Category One: Software Engineering/Design, I selected work done in CS320 – Software Testing, Automation and Quality Assurance, which focuses on locating and resolving software security vulnerabilities by creating secure code and testing procedures to locate issues before code implementation.   My enhancement plan included expanding the complexity of my Unit Test files created in Java and edited and implemented using Visual Studio, Terminal and XCode.  In addition, enhancements were made to the associated ContactTest.java and ContactServiceTest.java files linked to their respective java files.  This demonstrated skills learned in altering Java code to be more secure, as well as in the creation of efficient test files, created specifically for their respective java files for testing.  As seen in the Structural Model representation below, each unit test requirement has attributes and methods included which complete the process or unit test needs.
![StructuralModel](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/StructuralModel.png)
    
 </p>
</details>


## [Category II: Algorithm and Data Structures](#Introduction)
        - [Original II Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat2%20Initial.zip) 
        - [Enhancement II Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat2_Algorithm%20and%20Data%20Structures.zip)
        - [Enhancement II Narrative](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%202%20Narrative.docx)
<details><summary>CLICK TO EXPAND</summary>
<p>
For Artifact two in Category Two:  Algorithms and Data Structures, I selected work done in CS250 – Software Development LifeCycle (SDLC), which focuses on the Agile team roles and how their teamwork results in an overall rounded functional Java application where the code includes added functionality and imagery for a better user experience.  My enhancement plan includes expanding the current API complexity of my TopFiveTravelDestination.java and SlideShow.java files with added resource folder imagery to give the user a better visual experience viewing destination information through a simple GUI that is user friendly.  This was done through the enhancement of current Java code to include better code documentation to elaborate on code functionality resulting in minimal errors and a fluid transition between screens.  This demonstrates knowledge and skills gained in the use of Java coding to create simple applications that the user can easily manipulate but not corrupt.   Code was altered and tested using Java IDE, XCode application and Terminal applications for Mac.
![StructuralModel](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/StructuralModel.png)
</p>
</details>


## [Category III: Databases](#Introduction)
        - [Original III Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat3%20Initial.zip)
        - [Enhancement III Code](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat3_Databases.zip)
        - [Enhancement III Narrative](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%203%20Narrative.docx)        
<details><summary>CLICK TO EXPAND</summary>
<p>
For Artifact three in Category Three:  Databases, I will select work done in CS340 – Advanced Programming Concepts in Client/Server Development.  For this course I initially created a dynamic dashboard linking several databases in the Jupyter Notebook using .csv, .py, and .ipynb Python and Javascript language files in MongoDB.  The key databases to be used will be ProjectTwoDashboard.ipynb and Animal_App.py, with a aac_shelter_outcomes.csv file.  The objective is to apply database systems concepts and principles to create a client/server database application that interfaces with client-side code.  This will pull data to display geo-mapping, statistics, and other user data from a database powered by MongDB.  My enhancement plan will include expanding on the current MongoDB API (application programming interface) via JavaScript to make it more user friendly, as well as provide more selection options through improving on my current project code.  This includes enhancing CRUD (create, read, update, delete) elements of my code.  This will demonstrate skills learned in Python code when creating user interfaces and efficient CRUD implementation.  As shown below in the Behavior Model, the database will be improved upon to have more input options which in turn will have more varied results.
![BehavioralModel](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/BehavioralModel.png?raw=true)
</p>
</details>

## [ePortfolio Summary](#Introduction)
By fulfilling my enhancement plans, i will demonstrate skills learned in the languages of Java and Python that I would apply toward improving on my current code and using that knowledge to improve on the various API the code is controlling.  Namely the ability to create effective test files for their respective java files to ensure they function correctly.  As well, creating detailed CRUD functionality, adding Create, Read, Update and Delete functionality with safeguards included.  The only limitations I can see would be the lack of full expert knowledge in these languages which will hinder the code from being as expansive as it should be.  As well, if how are each of these to be demonstrated or presented in the GitHub site without access to specific applications.  They are not stand-alone apps and have to be run within their associated programs.  The only thing that will be viewed would be the source code itself.  






