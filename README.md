## Introduction
This ePortfolio contains a narrated code review, an ePortfolio Selection and Refinement Plan, enhancements to existing work in three categories:  Software Design and Engineering, Algorithms and Data Structure, and Databases, narratives justifying each enhancement, and a professional Self Assessment. These artifacts were initially created over the life of my time completing the Computer Science program at Southern New Hampshire University (SNHU).  The resulting enhancements expand on the basic principles of each category, and are intended to showcase my abilities in each area.   




## Table of Contents


* [Professional Self Assessment](#professional-self-assessment)
* Informal Code Review [(YouTube Link)](https://youtu.be/gQ-wygnmFLA)
* [ePortfolio Selection and Refinement Plan](#ePortfolio-selection-and-refinement-plan)
* [Category I: Software Engineering and Design](#category-i:-software-engineering-and-design)  
* [Category II: Algorithm and Data Structures](#ePortfolio-selection-and-refinement-plan)
* [Category III: Databases](#ePortfolio-selection-and-refinement-plan)


## [Professional Self Assessment](#Introduction)
[(Download)](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Professional%20Self%20Assessment.docx)

This Professional Self-Assessment will serve as a summation of my experiences navigating through the Computer Science program at SNHU and introduce the artifacts chosen for my final project in the Capstone class of the SNHU Computer Science program.  Completing my coursework throughout the Computer Science Program over the last four years and developing an ePortfolio has helped to showcase my strengths and shape my professional goals and values and helped me to be more employable in the computer science field.  

<details><summary>CLICK TO EXPAND</summary>
<p>

Learning to create effective security policies that implement structures that enforce coding standards and best practices, as well as how the Software Development Life Cycle (SDLC) functions has been instrumental in my understanding of team environment collaboration.  Understanding how each team member has their own classification and assigned duties, how they all link together to create solid planning, creating, testing and deployment stages was beneficial. understanding how everyone had their own assignment or branch off of the same project yet linked to the team as a whole for peer code review and testing, then finally submitted coding from their branches into the main structure for further development.  Understanding these concepts and being able to employ them will make me a more effective team member in the future.  For example, the CS-310 Collaboration and Group Project course introduced me to the GIT process and understanding version control, another definition of team collaboration using centralized project storage, with all members of a team accessing the latest version and merging it into their project branches, making the process seamless.

Another concept involving SDLC, communicating with stakeholders is an integral part of the process for a successful project.  As learned throughout this program, not gaining transparency and insight with the client or stakeholders will lead to process delay and possibly failure.  Keeping an open line of communication early in the process will clarify client requirements, work out any misunderstandings or gaps in communication, as well as minimize rehashing and altering development late in the cycle.  After all, the clients are the ones you are creating these projects for, so it is essential to understand one another’s mindset. 

Multiple classes throughout this program involved data structure and algorithm creation, as these are the building blocks for more advanced code to grow from.  Understanding how these are associated with each other and having the ability to express this through code is an essential component of the computer science program.  Most programs incorporate these concepts and would cease to function without them.  The concepts of databases and software engineering were found to be the most interesting, as they are the most visual with interactive GUI and understanding all that goes into ensuring a database program will function properly.  Included in this would be the addition of error handling and security measures to ensure minimal issues.  Security is a cornerstone of any project development to ensure no outside or inside forces gain unauthorized access to privileged data. This security can come in many shapes, to include multi factor authorization protocols, to physical security policies that companies can enforce to ensure data integrity.

Overall, I was introduced to Python in CS-200, CS-250 taught about Scrum, I learned testing and its importance in CS-310. I learned how to incorporate Discrete Math, Stats, Calculus, Physics, and Linear Algebra into computer science as a whole. I gained knowledge on databases and analyzing data. I learned about computational graphics and design. I now understand how to use Python, C++, Java, and other useful applications. All of these skills learned with be essential when utilizing them in my future endeavors.

**Final Portfolio Summary**

For this project, I chose three artifacts that made the most educational impact on me. I selected projects that I really believe I would continue to use in my professional life after the requirements for this class were completed. From software design and testing to base algorithm coding for working data structures, and the creation of user-friendly databases centered on the client requirements, all of these artifacts fit together to create a fully rounded demonstration of skills and abilities learned throughout this program.  

For the software design and engineering portion of the project, I applied what I learned in CS-320 Software Testing, Automation and Quality Assurance.   This centered around testing automated coding ion Javascript with adequate error handling through JUnit tests. To accomplish this, I took the skills that I learned in CS-320 and applied additional testing methods to include assertEquals, assertThrows and assertUpdate, as well as adding constructor variations that effectively test variable combinations entered by the user. This portion demonstrates my skills in software design and engineering by expanding the complexity of my error handling to cover a wide range of outcomes using Javascript.

For the algorithms and data structures portion of the project, I chose to apply my knowledge from CS-250 Software Development Life Cycle to enhance the efficiency and complexity of an API that displays working button controls, frame and panel attributes, and image and text selection.  This involved using multiple data structures to store image and sizing data, as well as associated descriptive text.  These have associated algorithms which employ postfix increment and decrement operators linked to button controls that in ultimately control which data and image set to display.  This demonstrates my skills with algorithms and data structures, as well as my ability to effectively use Javascript.

For the databases portion of the final project, I applied what I learned in the CS-340 Advanced Programming Concepts course and enhanced a mongoDB based database written in Python that will interface with a Node JS application. This application provides a user-friendly interface that pulls data from a central .csv file, with the objective of helping a client identify good dog candidates for search and rescue training through a dynamic dashboard web application that can be run either with MongoDB or Jupyter Notebook.  I incorporated what I learned about mongoDB and added in enhanced functionality to the password interface for added access security, and expanded coding for data creation, alteration and deletion into an existing data structure.  This incorporated additional error notifications and loops to enhance error handling.  This portion demonstrates my skills with databases, as well as my ability to use Python.
</p>
</details>



## [ePortfolio Selection and Refinement Plan](#Introduction)
[(Download)](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/ePortfolio%20Selection%20and%20Refinement%20Plan.docx)



## [Category I: Software Engineering and Design](#Introduction)
-[Original I Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat1%20Initial.zip)  

-[Enhancement I Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat1_Software%20Engineering%20and%20Design.zip)

-[Enhancement I Narrative Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%201%20Narrative.docx)
 
<details><summary>CLICK TO EXPAND</summary>
<p>

 For Artifact One in Category One: Software Engineering/Design, I selected work done in CS320 – Software Testing, Automation and Quality Assurance, which focuses on locating and resolving software security vulnerabilities by creating secure code and testing procedures to locate issues before code implementation.   My enhancement plan included expanding the complexity of my Unit Test files created in Java and edited and implemented using Visual Studio, Terminal and XCode.  In addition, enhancements were made to the associated ContactTest.java and ContactServiceTest.java files linked to their respective java files.  This demonstrated skills learned in altering Java code to be more secure, as well as in the creation of efficient test files, created specifically for their respective java files for testing.  As seen in the Structural Model representation below, each unit test requirement has attributes and methods included which complete the process or unit test needs.
 

<img width="228" alt="image" src="https://user-images.githubusercontent.com/73085066/184496102-ebdc6e07-cc5b-4e13-9b91-6d2c6d779ba1.png">


**Narrative**

The artifact includes a ContactTest.java file that implements JUnit methods to test the attributes of the Contact class.  The objective is to create tests that the ID is not null, updateable, and less than or equal to 10 characters.  You would also be testing a potential client’s needs for other variables such as firstName, lastName, phoneNumber and address.  These JUnit tests can be adjusted to be used with any additional parameters needed to validate the Contact class data.  This code was initially created during the CS320 course, with the intent to help the student learn various java functionality.

The ContactTest.java file and its associated Contact.java file were included in the ePorfolio as the test file code displayed the test variations that could be employed to effectively test variable combinations entered by the user.  Initially, the test file included specifically constructors that tested to ensure parameters for a new contact were asserted to have data, or a NotNull status.  The first one tested that all necessary variables were not null.  The next one tested to make sure the parameter entered matched the contactID, and that all other variables were NotNull.  This continues on testing for assertEquals() for both contactID and firstNameTest.  As the tests stopped there, I added several other assert variations such as assert.Update and assertThrows() and assertEquals() methods to validate or notify of an illegal argument.  Seen below are these additions. 

**Artifact I Code**

-These code snapshots below display constructor tests adding additional assertEquals() parameters 

<img width="215" alt="image" src="https://user-images.githubusercontent.com/73085066/184495900-0779d16d-4a32-45c3-8c02-569c5be371c0.png">

<img width="266" alt="image" src="https://user-images.githubusercontent.com/73085066/184495927-e5931d7f-d343-4c44-860a-14315a6bc728.png">

-These three sections below of added code include assertThrows() methods pinpointing an error with an Illegal Argument notification under conditions 
Documentation was added for each @test to ensure other developers will understand what was attempted here.  When modifying the artifact, I did a lot of code cross referencing online to better understand the purpose of the different assert methods, and how to implement them.  For this class, I could not access a virtual environment previously supplied by SNHU, so instead used available software such as XCode to view and alter as necessary.  As well, initial code was completed via a Windows OS, as now it was completed on a MacOS, which actually made it easier to manipulate. 

 
<img width="219" alt="image" src="https://user-images.githubusercontent.com/73085066/184496216-79ffa18f-6829-444f-a05d-87684b516fad.png">
 
<img width="218" alt="image" src="https://user-images.githubusercontent.com/73085066/184496244-7e815215-596a-4ff4-8cab-793cfb192894.png">
 
<img width="209" alt="image" src="https://user-images.githubusercontent.com/73085066/184496256-200732f5-a3a6-4f64-ba81-2234d8512dc8.png">


</p>
</details>


## [Category II: Algorithm and Data Structures](#Introduction)
-[Original II Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat2%20Initial.zip) 

-[Enhancement II Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat2_Algorithm%20and%20Data%20Structures.zip)

-[Enhancement II Narrative Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%202%20Narrative.docx)

<details><summary>CLICK TO EXPAND</summary>
<p>
For Artifact two in Category Two:  Algorithms and Data Structures, I selected work done in CS250 – Software Development LifeCycle (SDLC), which focuses on the Agile team roles and how their teamwork results in an overall rounded functional Java application where the code includes added functionality and imagery for a better user experience.  My enhancement plan includes expanding the current API complexity of my TopFiveTravelDestination.java and SlideShow.java files with added resource folder imagery to give the user a better visual experience viewing destination information through a simple GUI that is user friendly.  This was done through the enhancement of current Java code to include better code documentation to elaborate on code functionality resulting in minimal errors and a fluid transition between screens.  This demonstrates knowledge and skills gained in the use of Java coding to create simple applications that the user can easily manipulate but not corrupt.   Code was altered and tested using Java IDE, XCode application and Terminal applications for Mac.


**Narrative**

The artifact is a compilation of five vacation locations displaying an image along with a description that is supposed to entice the client to go there.  The artifact includes a TopFiveDestinationList.java and SlideShow.Java file that are two variations on the same project, that implements JFrames, JLabels and JPanels along with Button Controls to assist in maneuver.  This code was initially created during the CS250 course, with the intent to help the student learn java functionality and project images and descriptions onto a structured display.

The TopFiveDestinationList.java and SlideShow.Java files were selected to be included in the ePorfolio as both showed the potential to demonstrate multiple displays of code functionality for the creation of working button controls, frame and panel attributes, and the insertion of images and text using if/else loops, the addition of colored backgrounds, borders, and the conversion of these files into a runnable jar file.  Initially, the files included base code structures to allow for the insertion of images and text, with no declared variables to allow for panes and framework.  The artifact was improved by declaring these variables, initializing them, setting up frame attributes and panel layouts, adding functionality for the previous and next buttons, and adding imagery and text with code to allow them to be displayed through a method that included if/else loops.  Seen below in the artifact code section are images and code of these additions. 


**Artifact II Code**

The code below demonstrates the insertion of imagery and text linked to images in the resource file, using if/else statements to determine which image to display.  This is code from SlideShow.java.  The two data structures shown are used to store image and image sizing data.  This was enhanced to pull in images from the resource file and define their measurements.  These are the Methods to get the images and text.  It also links to imagery in the resource file folder.  The button code pulls back to this structure, determining which image and text to display.

<img width="389" alt="image" src="https://user-images.githubusercontent.com/73085066/184497568-c412308d-b676-43a2-bff8-25dfd009889e.png">


The code below displays Previous and Next Button algorithms, along with logic that is uses to determine the image and text slides to display.


<img width="329" alt="image" src="https://user-images.githubusercontent.com/73085066/184497296-3ba037ff-c637-4c35-a711-0d772b74e344.png">

<img width="329" alt="image" src="https://user-images.githubusercontent.com/73085066/184497320-e986f9bb-a45f-4987-806f-cf8fb38cd201.png">

<img width="329" alt="image" src="https://user-images.githubusercontent.com/73085066/184497326-497f7a6d-a154-4ef0-b4fe-b13353c4feb5.png">


The algorithm created to add each of the slides and text as seen here sets parameters for the Previous and Next buttons, adding to their functionality.  this segment of code which uses a postfix increment operator that assigns a number first then adds one to the given value incrementally.  This algorithm is then linked to the previous and next buttons which identify which number the increment operator assigned and uses that number to pull from both data structures and combine them into one slide frame. The initComponent method has this segment of code below as an algorithm which identifies which number the increment operator assigned, by using both the previous and next buttons, determine the line number to pull from both data structures and combine them into one slide frame.  Previous Button Functionality Is linked to the previous code to add functionality. It will use the increment operator to go back one number from the currently assigned one, then go back to the previous pane.

<img width="212" alt="image" src="https://user-images.githubusercontent.com/73085066/184497641-47602be4-40a9-4244-8c13-f53962ab077f.png">

<img width="212" alt="image" src="https://user-images.githubusercontent.com/73085066/184497664-b6a2d7ae-2e4b-433b-b518-f05dc6b423cb.png">

Above are examples of the results of the code, with various vacation destinations displayed, along with descriptive text, a title for the program, and functional buttons allowing the client to scan through all the slideshow pages.

<img width="358" alt="image" src="https://user-images.githubusercontent.com/73085066/184497888-3e2b0aee-b9b3-4768-96bc-e3690765bf34.png">


The code above shows that Eclipse IDE environment was used to enhance data structure code for the TopFiveDestinationList.java file.  This was also used to convert both java files to runnable jar files that you can open without the necessity of using an IDE or other environment. The enhancements met my goals for overall improvements as it increased functionality in several different areas as determined in the Code Review.   The objective is to identify, enhance and comment on data structures in the code and their associated algorithms. Data structures are used to store and organize data.  The identified algorithms are used to manipulate the data in their associated structures.

The two data structures in the SlideShow.java file are identified as:

a.  The getResizeIcon method, which is used to store image and image sizing data.  This was enhanced to pull in images from the resource file.  
b.  The getTextDescription method, which is used to store descriptive data for each image. 

I believe this embodies several categories of improvement, showing emerging abilities as indicators of success.

The two associated algorithms in the SlideShow.java file are identified as:

a.  The initComponent method has a segment of code which  uses a postfix increment operator that assigns a number first then adds one to the given value incrementally.  This algorithm is pulls from the two data structures to determine which data to pull from it and display.  
b.  The second associated algorithm originates from the same initComponent method, where the code has the button action identify which number the increment operator assigned, and uses that to pull from both data structures and combine them into one slide frame. The button algorithm will determine whether to subtract one number from the postfix increment operator or add one number, depending on the button activated, then go to the next or previous slide and text pane.

When modifying the artifact, I once again did a lot of code cross referencing online through stackoverflow.com and other sites to better understand the purpose of the different assert methods, and how to implement them.  I understand these sites give examples of code that are not necessarily correct, so code I used needed to be adjusted to be functional.  This was a great learning tool for me.  However, code used in the Slideshow.java file was more functional than its counterpart TopFiveDestinationList.java, but I have included both files to demonstrate the differences in workable functionality.  For this class, I could not access a virtual environment previously supplied by SNHU, so instead again used available software such as XCode to view and alter as necessary.  This code was then placed into a downloaded version of Eclipse IDE for Mac, where I could further alter code, then create a runnable jar file in addition to the saved java file.  


</p>
</details>


## [Category III: Databases](#Introduction)
-[Original III Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat3%20Initial.zip)

-[Enhancement III Code Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Cat3_Databases.zip)

-[Enhancement III Narrative Download](https://github.com/michaelpclisbee/michaelpclisbee.github.io/blob/main/Category%203%20Narrative.docx) 

<details><summary>CLICK TO EXPAND</summary>
<p>
For Artifact three in Category Three:  Databases, I will select work done in CS340 – Advanced Programming Concepts in Client/Server Development.  For this course I initially created a dynamic dashboard linking several databases in the Jupyter Notebook using .csv, .py, and .ipynb Python and Javascript language files in MongoDB.  The key databases to be used will be ProjectTwoDashboard.ipynb and Animal_App.py, with a aac_shelter_outcomes.csv file.  The objective is to apply database systems concepts and principles to create a client/server database application that interfaces with client-side code.  This will pull data to display geo-mapping, statistics, and other user data from a database powered by MongDB.  My enhancement plan will include expanding on the current MongoDB API (application programming interface) via JavaScript to make it more user friendly, as well as provide more selection options through improving on my current project code.  This includes enhancing CRUD (create, read, update, delete) elements of my code.  This will demonstrate skills learned in Python code when creating user interfaces and efficient CRUD implementation.  As shown below in the Behavior Model, the database will be improved upon to have more input options which in turn will have more varied results.

<img width="234" alt="image" src="https://user-images.githubusercontent.com/73085066/184498191-e5cace9c-acd1-4c05-bf4f-0d566b0be59e.png">

**Narrative**

This artifact is an application the purpose of which is to provide a user-friendly interface to pull information from a database written in Python and powered by MongoDB, to retrieve information from animals, namely dogs, and update or alter same database.  The objective of this project is to create a database, an API and a dynamic dashboard with the dashboard a web application designed for the client to identify good dog candidates for search and rescue training.    This was originally created in the CS 340 SNHU course for Advanced Programming Concepts, with minimal functionality and no security.

This project can be used to query MongoDB by creating and reading data from MongoDB.  For the purposes of this milestone, it was altered and run via Jupyter Notebook, as well as the XCode application.  Jupyter Notebook was accessed for Mac via the Anaconda.Navigator application.  

This artifact was selected to represent Category 3:  Databases, as it represents what a fully structured database and its code can do, from an effective API and a base data file to CRUD functionality that enables the creation, readability, update capability and delete functionality, all of which are essential in creating a functional database.  Some specific components that showcase skills learned would include enhancements to the password interface for added security, expanded coding for data creation and insertion into existing .csv file, expanded search functions in the ReadData operation to effectively search for existing data and display it, expanded update operations with easy to understand input keys to include error notifications and if/else loops, and delete functionality to include error notifications and if/else loops to eliminate  existing data.

The enhancements met my goals for overall improvements as it increased functionality in several different areas as determined in the Code Review.   The objective for this milestone is to identify, enhance and comment on the database elements and structures involved with maintaining and updating it.  My goal was to make it an entirely functional database, but am still working on the unique password to username coding as well as the visual displays which are not populating due to minor coding errors.

When modifying the artifact, I did code referencing online to get ideas on how best to create a polished code.  I learned several ways of writing the CRUD functionality to try and cover all possible errors, as well as how detailed the dashboard code needed to be to provide any sort of functionality.  However, one of the challenges I faced was understanding certain coding aspects that would help me correct some errors that popped up.  I think that if this had a peer review element to it, having the perspective of several other developers’ opinions would go a long way towards making this program fully functional. 


**Artifact III Code**

<img width="367" alt="image" src="https://user-images.githubusercontent.com/73085066/184498357-5bc97f1b-1bd9-445c-afc7-488f4698ac37.png">

The aac_shelter_outcomes.csv file is central to the mission of the database program.  Here is existing data that will be either adjusted, deleted, added to, or searched through as long as the base code works as needed.  Below is an example initial and final code enhancements for the C operation for C in CRUD, to create new lines of data in the .csv file. Initial code before enhancement for Create

<img width="260" alt="image" src="https://user-images.githubusercontent.com/73085066/184506100-02d04085-611e-4adf-8438-d92a394d90a1.png">


Created code after enhancements that involved adding code to ensure user enters correct data fields.  The first part of the Create code collects the data, while the second part validates and inserts results, or issues Exceptions via if/else statements.


<img width="264" alt="image" src="https://user-images.githubusercontent.com/73085066/184506136-f5947b5e-b106-42aa-aa1f-7fc5a026fafa.png">


The following Code adds security to application by adding username and password requirements.  Still need to work out so unique passwords can be saved per username. 

<img width="264" alt="image" src="https://user-images.githubusercontent.com/73085066/184498461-59567e9a-51ee-42a6-9075-2062630797d9.png">

This is part of the final dashboard code that includes unique client logo, dashboard title and radio items to select rescue filters based on the client requirements. This code can be altered to meet client needs.  

The Dashboard code is set up to collect all data and depending on data selected, create a specific pie chart and geolocation chart.  This code is still being perfected, so cannot be displayed currently. 

<img width="282" alt="image" src="https://user-images.githubusercontent.com/73085066/184498504-d796b08b-371f-4386-8e8b-c5970898614a.png">


</p>
</details>



## [ePortfolio Summary](#Introduction)
By fulfilling my enhancement plans, i will demonstrate skills learned in the languages of Java and Python that I would apply toward improving on my current code and using that knowledge to improve on the various API the code is controlling.  Namely the ability to create effective test files for their respective java files to ensure they function correctly.  As well, creating detailed CRUD functionality, adding Create, Read, Update and Delete functionality with safeguards included.  The only limitations I can see would be the lack of full expert knowledge in these languages which will hinder the code from being as expansive as it should be.  As well, if how are each of these to be demonstrated or presented in the GitHub site without access to specific applications.  They are not stand-alone apps and have to be run within their associated programs.  The only thing that will be viewed would be the source code itself.  






